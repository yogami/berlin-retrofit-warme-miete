import { Router } from 'express';
import { simulations, auditLogs } from '../infrastructure/schema';
import { eq, desc } from 'drizzle-orm';
import { CryptoAuditTrail } from '../domain/CryptoAuditTrail';
import { memoryDb } from '../infrastructure/memoryDb';
import { z } from 'zod';

// STRICT ZERO-TRUST SCHEMA
// We explicitly forbid any PII from entering the system.
const simulationPayloadSchema = z.object({
    name: z.string(),
    params: z.object({
        units: z.number().positive(),
        buildingAge: z.string(),
        retrofitType: z.enum(['basic', 'standard', 'deep']),
        baseRentPerUnit: z.number().optional().default(0),
        heatingPerUnit: z.number().optional().default(0),
        avRatio: z.number().optional(),
        pvRevenue: z.number().optional()
    }).strict(),
    results: z.any() // results generated by our engine, verified via hash later
}).strict();

export const createSimulationsRouter = (db: any) => {
    const router = Router();

    // READ: Get all saved simulations
    router.get('/', async (req, res) => {
        try {
            if (!db) {
                // Return in-memory data
                const joinedData = memoryDb.simulations.map(sim => {
                    const audit = memoryDb.auditLogs.find(a => a.simulationId === sim.id);
                    return { ...sim, hash: audit ? audit.hash : null };
                }).sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()).slice(0, 20);
                return res.status(200).json({ success: true, data: joinedData });
            }

            // Join simulations with auditLogs to provide the hash back to the client
            const data = await db
                .select({
                    id: simulations.id,
                    units: simulations.units,
                    buildingAge: simulations.buildingAge,
                    retrofitType: simulations.retrofitType,
                    results: simulations.results,
                    createdAt: simulations.createdAt,
                    hash: auditLogs.hash
                })
                .from(simulations)
                .leftJoin(auditLogs, eq(simulations.id, auditLogs.simulationId))
                .orderBy(desc(simulations.createdAt))
                .limit(20);

            res.status(200).json({ success: true, data });
        } catch (error: any) {
            res.status(500).json({ success: false, error: error.message });
        }
    });

    // CREATE: Save a new simulation
    router.post('/', async (req, res) => {
        try {
            // Validate against the Zero-Trust Schema
            const parseResult = simulationPayloadSchema.safeParse(req.body);

            if (!parseResult.success) {
                return res.status(403).json({
                    success: false,
                    message: parseResult.error.issues[0]?.message || "Zero-Trust Architecture: Data compliance validation failed. PII or extraneous fields are strictly prohibited."
                });
            }

            const { name, params, results } = parseResult.data;

            // 1. Generate Cryptographic Proof
            const crypt = new CryptoAuditTrail();
            const { hash, payload } = crypt.generateHash(params, results);

            if (!db) {
                // In-memory fallback
                const simRecord = {
                    id: memoryDb.idCounter++,
                    units: params.units,
                    buildingAge: params.buildingAge,
                    retrofitType: params.retrofitType,
                    results: results,
                    createdAt: new Date()
                };
                memoryDb.simulations.push(simRecord);

                memoryDb.auditLogs.push({
                    id: memoryDb.idCounter++,
                    simulationId: simRecord.id,
                    hash,
                    payload,
                    createdAt: new Date()
                });
                return res.status(200).json({ success: true, data: { name, ...simRecord, hash } });
            }

            // 2. Save Simulation
            const inserted = await db.insert(simulations).values({
                units: params.units,
                buildingAge: params.buildingAge,
                retrofitType: params.retrofitType,
                results: results,
            }).returning();

            const simulationId = inserted[0].id;

            // 3. Save Immutable Audit Log
            await db.insert(auditLogs).values({
                simulationId,
                hash,
                payload
            });

            res.status(200).json({ success: true, data: { name, ...inserted[0], hash } });
        } catch (error: any) {
            console.error(error);
            res.status(500).json({ success: false, error: error.message });
        }
    });

    // DELETE: Remove a saved simulation
    router.delete('/:id', async (req, res) => {
        try {
            const id = parseInt(req.params.id);
            if (!db) {
                memoryDb.simulations = memoryDb.simulations.filter(s => s.id !== id);
                memoryDb.auditLogs = memoryDb.auditLogs.filter(a => a.simulationId !== id);
                return res.status(200).json({ success: true, message: 'Deleted successfully (memory)' });
            }

            await db.delete(simulations).where(eq(simulations.id, id));

            res.status(200).json({ success: true, message: 'Deleted successfully' });
        } catch (error: any) {
            res.status(500).json({ success: false, error: error.message });
        }
    });

    return router;
};
